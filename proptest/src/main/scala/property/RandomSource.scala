/*
 * Copyright (c) 2024, Ignacio Slater M.
 * 2-Clause BSD License.
 */

package cl.ravenhill.plascevo
package property

import cl.ravenhill.composerr.Constrained
import cl.ravenhill.composerr.Constrained.{constrained, constrainedTo}
import cl.ravenhill.composerr.constraints.ints.BeAtMost
import cl.ravenhill.composerr.constraints.iterable.BeEmpty
import cl.ravenhill.composerr.constraints.doubles.{BeAtMost => BeAtMostDouble}
/**
 * Represents a source of randomness, encapsulating a random number generator and its seed.
 *
 * The `RandomSource` case class combines a random number generator (`scala.util.Random`) with its corresponding seed.
 * This is useful in contexts where deterministic reproducibility is important, such as in property-based testing or
 * simulations. By storing both the `Random` instance and the seed, you can recreate the exact same sequence of random
 * numbers later by reinitializing the generator with the same seed.
 *
 * @param random The instance of `scala.util.Random` used for generating random numbers.
 * @param seed   The seed value used to initialize the `random` generator. This seed ensures that the random number
 *               sequence generated by `random` can be reproduced.
 */
case class RandomSource(random: scala.util.Random, seed: Long)

/**
 * Companion object for `RandomSource`, providing methods to create instances of `RandomSource` with either a specific
 * seed or a randomly generated seed.
 *
 * The `RandomSource` object provides two primary methods: `seeded`, which creates a `RandomSource` with a specified
 * seed, and `default`, which creates a `RandomSource` with a randomly initialized seed. These methods are useful for
 * creating reproducible random number generators or for generating random numbers in a non-deterministic manner.
 */
object RandomSource {

    /**
     * Creates a `RandomSource` initialized with the specified seed.
     *
     * The `seeded` method generates a `RandomSource` using the provided seed. This allows for deterministic random
     * number generation, where the same seed will always produce the same sequence of random numbers. This is
     * particularly useful in testing or scenarios where reproducibility is required.
     *
     * @param seed The seed to initialize the `RandomSource`. The same seed will always produce the same sequence of
     *             random numbers.
     * @return A `RandomSource` initialized with the provided seed.
     */
    def seeded(seed: Long): RandomSource = RandomSource(scala.util.Random(seed), seed)

    /**
     * Generates a default `RandomSource` with a randomly initialized seed.
     *
     * The `default` method creates a new `RandomSource` by generating a random seed using the `scala.util.Random`
     * class. This seed is then used to initialize a new instance of `scala.util.Random`, ensuring that the resulting
     * random number generator is both random and non-deterministic. The method returns the `RandomSource` containing
     * the randomly generated seed and the corresponding `scala.util.Random` instance.
     *
     * @return A `RandomSource` initialized with a randomly generated seed. The seed is stored within the `RandomSource`
     *         for potential reproducibility or logging purposes.
     */
    def default: RandomSource = {
        val seed: Long = scala.util.Random().nextLong()
        seeded(seed)
    }

    extension (random: scala.util.Random) {
        /**
         * Generates a random integer within a specified `Range`.
         *
         * The `nextInt` function generates a random integer within the bounds of the given `range`. The method ensures
         * that the `range` is non-empty by applying a constraint check before proceeding.
         * 
         * @param range The `Range` within which to generate the random integer. The range must not be empty.
         * @return A random integer within the specified `range`.
         * @throws CompositeException containing all the constraints that failed.
         * @throws IterableConstraintException if the `range` is empty; wrapped in a `CompositeException`.
         */
        def nextInt(range: Range): Int = {
            range.constrainedTo {
                "Range must not be empty" | {
                    range mustNot BeEmpty()
                }
            } match {
                case r if r.last < Int.MaxValue => random.between(r.head, r.last + 1)
                case r if r.head > Int.MinValue => random.between(r.head - 1, r.last) + 1
                case _ => random.nextInt()
            }
        }
    }

    /**
     * Computes the base-2 logarithm (log2) of a given integer.
     *
     * The `fast2Log` function efficiently computes the base-2 logarithm of a given integer `n`. This is achieved by
     * determining the position of the highest set bit (the most significant bit) in the binary representation of `n`.
     * The result is equivalent to `floor(log2(n))`, which gives the largest integer `k` such that `2^k <= n`.
     *
     * @param n The integer for which the base-2 logarithm is computed. It must be a positive integer.
     * @return The base-2 logarithm of `n`, effectively the position of the highest set bit.
     */
    private def fast2Log(n: Int): Int = 31 - Integer.numberOfLeadingZeros(n)
}
